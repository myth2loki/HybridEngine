/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_xhrd_mobile_hybridframework_util_EncryptUtil */
#include "string.h"
#include "android/log.h"
#include "blowfish.h"

#ifndef _Included_com_xhrd_mobile_hybridframework_util_EncryptUtil
#define _Included_com_xhrd_mobile_hybridframework_util_EncryptUtil
#ifdef __cplusplus
extern "C" {
#endif

#define TYPE 1
#define VERSION 1

#define TAG "jni_encrypt"
//this is password for decryption
#define PWD "test_pwd"
#define PKG_NAME "com.xhrd.mobile.hybridframework"
#define SIGNATURE ""
#define MAX_BUFF 8
#define HEX_CONV 0

using namespace std;

static CBlowFish *cbf;
static bool isVerified = false;

#define LOGV(...)  __android_log_print(ANDROID_LOG_VERBOSE,TAG,__VA_ARGS__) // 定义LOGV类型
#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,TAG,__VA_ARGS__) // 定义LOGD类型
#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__) // 定义LOGI类型
#define LOGW(...)  __android_log_print(ANDROID_LOG_WARN,TAG,__VA_ARGS__) // 定义LOGW类型
#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__) // 定义LOGE类型

////change type string into char*
//char* jstrToStr(JNIEnv* env, jstring jstr) {
//	char* rtn = NULL;
//	jclass clsstring = env->FindClass("java/lang/String");
//	jstring strencode = env->NewStringUTF("utf-8");
//	jmethodID mid = env->GetMethodID(clsstring, "getBytes", "(Ljava/lang/String;)[B");
//	jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr, mid, strencode);
//	jsize alen = env->GetArrayLength(barr);
//	jbyte* ba = env->GetByteArrayElements(barr, JNI_FALSE);
//	if (alen > 0) {
//		rtn = (char*)malloc(alen + 1);
//		memcpy(rtn, ba, alen);
//		rtn[alen] = 0;
//	}
//	env->ReleaseByteArrayElements(barr, ba, 0);
//	return rtn;
//}
//
//bool isDebug(JNIEnv *env) {
//	//com.xhrd.mobile.hybridframework.R.id
//	jclass cls = env->FindClass("com/xhrd/mobile/hybridframework/BuildConfig");
//	if (cls == NULL) {
//		return false;
//	}
//	jfieldID debugId = env->GetStaticFieldID(cls, "DEBUG", "Z");
//	if (!debugId) {
//		return false;
//	}
//	jboolean ret = env->GetStaticBooleanField(cls, debugId);
//	return (bool)ret;
//}
//
///**
// * 获取包名
//**/
//jstring getPackageName(JNIEnv *env) {
//	jclass cls = env->FindClass("com/xhrd/mobile/hybridframework/framework/RDCloudApplication");
//	if (cls == NULL) {
//		return NULL;
//	}
//	jmethodID appId = env->GetStaticMethodID(cls, "getApp", "()Lcom/xhrd/mobile/hybridframework/framework/RDCloudApplication;");
//	if (!appId) {
//		return NULL;
//	}
//	jobject App = env->CallStaticObjectMethod(cls, appId);
//	if (!App) {
//		return NULL;
//	}
//	jmethodID pkgId = env->GetMethodID(cls, "getPackageName", "()Ljava/lang/String;");
//	if (!pkgId) {
//		return NULL;
//	}
//	return (jstring)env->CallObjectMethod(App, pkgId);
//}

static jmethodID getBytesMid;
//change type string into char*
char* jstrToStr(JNIEnv* env, jstring jstr) {
	char* rtn = NULL;
	if (getBytesMid == NULL) {
		jclass clsstring = env->FindClass("java/lang/String");
		getBytesMid = env->GetMethodID(clsstring, "getBytes", "(Ljava/lang/String;)[B");
	}
	jstring strencode = env->NewStringUTF("utf-8");
	jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr, getBytesMid, strencode);
	jsize alen = env->GetArrayLength(barr);
	jbyte* ba = env->GetByteArrayElements(barr, JNI_FALSE);
	if (alen > 0) {
		rtn = (char*)malloc(alen + 1);
		memcpy(rtn, ba, alen);
		rtn[alen] = 0;
	}
	env->ReleaseByteArrayElements(barr, ba, 0);
	return rtn;
}

static jclass buildConfigCls;
static jfieldID debugId;
bool isDebug(JNIEnv *env) {
	if (!debugId || !buildConfigCls) {
		//com.xhrd.mobile.hybridframework.R.id
		buildConfigCls = env->FindClass("com/xhrd/mobile/hybridframework/BuildConfig");
		if (!buildConfigCls) {
			return false;
		}
		debugId = env->GetStaticFieldID(buildConfigCls, "DEBUG", "Z");
	}
	if (!debugId) {
		return false;
	}
	jboolean ret = env->GetStaticBooleanField(buildConfigCls, debugId);
	return (bool)ret;
}

static jclass appClass;
static jmethodID appId;
static jmethodID pkgId;
/**
 * 获取包名
**/
jstring getPackageName(JNIEnv *env) {
	if (!appClass || !pkgId || !appId) {
		appClass = env->FindClass("com/xhrd/mobile/hybridframework/framework/RDCloudApplication");
		if (!appClass) {
			return NULL;
		}
		appId = env->GetStaticMethodID(appClass, "getApp", "()Lcom/xhrd/mobile/hybridframework/framework/RDCloudApplication;");
		if (!appId) {
			return NULL;
		}
		pkgId = env->GetMethodID(appClass, "getPackageName", "()Ljava/lang/String;");
		if (!pkgId) {
			return NULL;
		}
	}
    jobject app = env->CallStaticObjectMethod(appClass, appId);
    if (!app) {
        return NULL;
    }
	return (jstring)env->CallObjectMethod(app, pkgId);
}

//Function to convert unsigned char to string of length 2
void Char2Hex(const unsigned char ch, char* szHex)
{
	unsigned char byte[2];
	byte[0] = ch/16;
	byte[1] = ch%16;
	for(int i=0; i<2; i++)
	{
		if(byte[i] >= 0 && byte[i] <= 9)
			szHex[i] = '0' + byte[i];
		else
			szHex[i] = 'A' + byte[i] - 10;
	}
	szHex[2] = 0;
}

//Function to convert string of length 2 to unsigned char
void Hex2Char(const char* szHex, unsigned char& rch)
{
	rch = 0;
	for(int i=0; i<2; i++)
	{
		if(*(szHex + i) >='0' && *(szHex + i) <= '9')
			rch = (rch << 4) + (*(szHex + i) - '0');
		else if(*(szHex + i) >='A' && *(szHex + i) <= 'F')
			rch = (rch << 4) + (*(szHex + i) - 'A' + 10);
		else
			break;
	}
}

//Function to convert string of unsigned chars to string of chars
void CharStr2HexStr(const unsigned char* pucCharStr, char* pszHexStr, int iSize)
{
	int i;
	char szHex[3];
	pszHexStr[0] = 0;
	for(i=0; i<iSize; i++)
	{
		Char2Hex(pucCharStr[i], szHex);
		strcat(pszHexStr, szHex);
	}
}

//Function to convert string of chars to string of unsigned chars
void HexStr2CharStr(const char* pszHexStr, unsigned char* pucCharStr, int iSize)
{
	int i;
	unsigned char ch;
	for(i=0; i<iSize; i++)
	{
		Hex2Char(pszHexStr+2*i, ch);
		pucCharStr[i] = ch;
	}
}

//解密字符串
char* encrypt_chars(char* _text, int _size)
{
	int i;
	unsigned char buff[MAX_BUFF];
	int last_length = _size % MAX_BUFF;
	int block_size = _size / MAX_BUFF;
	char *arr = NULL;
	if (last_length > 0) {
		arr = new char[_size + MAX_BUFF - last_length + 1];
		arr[_size + MAX_BUFF - last_length] = '\0';
	} else {
		arr = new char[_size + 1];
		arr[_size] = '\0';
	}

	for (i = 0; i < block_size; i++) {
		for (int j = 0; j < MAX_BUFF; j++) {
			buff[j] = _text[i * MAX_BUFF + j];
		}
		cbf->Encrypt((unsigned char*)buff, MAX_BUFF);
		for (int j = 0; j < MAX_BUFF; j++) {
			arr[i * MAX_BUFF + j] = buff[j];
		}
	}

	/* An EOF is reached before counting 8 chars. Pad remaining with 0s and encrypt */
	if (last_length > 0) {
		for (i = 0; i < MAX_BUFF; i++){
			buff[i] = 0;
		}
		for (i = 0; i < last_length; i++) {
			buff[i] = _text[block_size * MAX_BUFF + i];
		}
		cbf->Encrypt((unsigned char*)buff, MAX_BUFF);
		for (i = 0; i < MAX_BUFF; i++) {
			arr[block_size * MAX_BUFF + i] = buff[i];
		}
		//arr[last_length] = '\0';
	}
	return arr;
}

//解密字符串
char* decrypt_chars(char* _text, int _size)
{
	int i;
	unsigned char buff[MAX_BUFF];
	int last_length = _size % MAX_BUFF;
	int block_size = _size / MAX_BUFF;
	char *arr = NULL;
	if (last_length > 0) {
		arr = new char[_size + MAX_BUFF + 1];
		arr[_size + MAX_BUFF] = '\0';
	} else {
		arr = new char[_size + 1];
		arr[_size] = '\0';
	}

	for (i = 0; i < block_size; i++) {
		for (int j = 0; j < MAX_BUFF; j++) {
			buff[j] = _text[i * MAX_BUFF + j];
		}
		cbf->Decrypt((unsigned char*)buff, MAX_BUFF);
		for (int j = 0; j < MAX_BUFF; j++) {
			arr[i * MAX_BUFF + j] = buff[j];
		}
	}

	/* An EOF is reached before counting 8 chars. Pad remaining with 0s and encrypt */
	if (last_length > 0) {
		for (i = 0; i < MAX_BUFF; i++){
			buff[i] = ' ';
		}
		for (i = 0; i < last_length; i++) {
			buff[i] = _text[block_size * MAX_BUFF + i];
		}
		cbf->Decrypt((unsigned char*)buff, MAX_BUFF);
		for (i = 0; i < MAX_BUFF; i++) {
			arr[block_size * MAX_BUFF + i] = buff[i];
		}
		//arr[last_length] = '\0';
	}
	return arr;
}

char* encrypt_chars_hex(char* _text, int _size) {
	char *ret = encrypt_chars(_text, _size);
	if (HEX_CONV) {
		int len = 0;
		int delta = _size % MAX_BUFF;
		if (delta > 0) {
			len = (_size + MAX_BUFF - delta + 1) * 2;
		} else {
			len = (_size + 1) * 2;
		}
		char *cp = new char[len];
		if (delta > 0) {
			len = _size + MAX_BUFF - delta;
		} else {
			len = _size;
		}
		CharStr2HexStr((unsigned char *) ret, cp, len);
		delete[] ret;
		return cp;
	} else {
		return ret;
	}
}

char *decrypt_chars_hex(char* _text, int _size) {
	char *ret = NULL;
	int size = 0;
    if (HEX_CONV) {
		size = _size / 2;
		ret = new char[_size / 2];
		HexStr2CharStr(_text, (unsigned char *) ret, size);
	} else {
		size = _size;
		ret = new char[size];
    }
	char *ret1 = decrypt_chars(_text, size);
	return ret1;
}

JNIEXPORT int native_check(JNIEnv *env, jclass clazz, jbyteArray array) {
    jsize len = env->GetArrayLength(array);
    if (len > 8) {
        jbyte *arr = env->GetByteArrayElements(array, 0);
        jbyte start = arr[0];
        jbyte end = arr[7];
        if (start == -0x1 && end == -0x1) {
            jbyte type = arr[5];
            jbyte version = arr[6];
            return (type == TYPE && version == VERSION) ? 1 : 0;
        }
        env->ReleaseByteArrayElements(array, arr, 0);
    }
    return 0;
}

///*
// * Class:     com_xhrd_mobile_hybridframework_util_EncryptUtil
// * Method:    encrypt
// * Signature: ([B)[B
// */
//JNIEXPORT jbyteArray JNICALL native_encrypt(JNIEnv *env, jclass clazz, jbyteArray array) {
////    jsize length = env->GetArrayLength(array);
////    jbyte buffer[length + 1];
////    env->GetByteArrayRegion(array, 0, length, buffer);
////    buffer[length] = '\0';
////	if (isVerified) {
////		if (!checkSignature(env) || !checkPackageName(env)) {
////			LOGE("%s", "check signature failed.");
////			return NULL;
////		}
////		isVerified = !isVerified;
////	}
//	jsize length = env->GetArrayLength(array);
//	jbyte *buffer = env->GetByteArrayElements(array, 0);
//
//	char *cp = encrypt_chars_hex((char*)buffer, length);
//	int len = strlen(cp);
//	jbyteArray ja = env->NewByteArray(len);
//	env->SetByteArrayRegion(ja, 0, len, (jbyte*)cp);
//	delete[] cp;
//	env->ReleaseByteArrayElements(array, buffer, 0);
//	return ja;
//}

/*
 * Class:     com_xhrd_mobile_hybridframework_util_EncryptUtil
 * Method:    decrypt
 * Signature: ([B)[B
 */
JNIEXPORT jbyteArray JNICALL native_decrypt(JNIEnv *env, jclass clazz, jbyteArray array) {
//    jsize length = env->GetArrayLength(array);
//    jbyte buffer[length + 1];
//    env->GetByteArrayRegion(array, 0, length, buffer);
//    buffer[length] = '\0';
//	if (isVerified) {
//		if (!checkSignature(env) || !checkPackageName(env)) {
//			LOGE("%s", "check signature failed.");
//			return NULL;
//		}
//		isVerified = !isVerified;
//	}
    if (native_check(env,clazz, array) == 1) {
		jsize length = env->GetArrayLength(array);
		jbyte *buffer = env->GetByteArrayElements(array, 0);
		char *cp = NULL;
        jbyte *buffer1 = buffer + 8;
        length -= 8;
	    cp = decrypt_chars_hex((char*)buffer1, length);
		int len = 0;
		if (HEX_CONV) {
			len = length / 2;
		} else {
			len = length;
		}
		jbyteArray ja = env->NewByteArray(len);
		env->SetByteArrayRegion(ja, 0, len, (jbyte*)cp);
		delete[] cp;
		env->ReleaseByteArrayElements(array, buffer, 0);
		return ja;
    } else {
        return array;
    }
}

/*
* Class:     com_xhrd_mobile_hybridframework_util_EncryptUtil
* Method:    getType
* Signature: ()I
*/
JNIEXPORT jint JNICALL native_getType
		(JNIEnv *env, jclass clazz) {
	return TYPE;
}

/*
* Class:     com_xhrd_mobile_hybridframework_util_EncryptUtil
* Method:    getVersion
* Signature: ()I
*/
JNIEXPORT jint JNICALL native_getVersion
		(JNIEnv *env, jclass clazz) {
	return VERSION;
}

/*
 * Class:     com_xhrd_mobile_hybridframework_util_EncryptUtil
 * Method:    init
 * Signature: ()V
 */
JNIEXPORT void JNICALL native_init
(JNIEnv *, jclass){
	char *key = PWD;
	cbf = new CBlowFish((unsigned char*)key, strlen(key));
}

/*
 * Class:     com_xhrd_mobile_hybridframework_util_EncryptUtil
 * Method:    close
 * Signature: ()V
 */
JNIEXPORT void JNICALL native_close
(JNIEnv *, jclass) {
	if (cbf) {
		delete cbf;
	}
}

static JNINativeMethod s_methods[] = {
		{"init", "()V", (void*)&native_init},
		{"close", "()V", (void*)&native_close},
		//{"encrypt", "([B)[B", (void*)&native_encrypt},
		{"decrypt", "([B)[B", (void*)&native_decrypt},
		{"check", "([B)I", (void*)&native_check},
		{"getType", "()I", (void*)&native_getType},
		{"getVersion", "()I", (void*)&native_getVersion}
};

//int checkSignature(JNIEnv *env) {
//	jclass appClass = env->FindClass("com/xhrd/mobile/hybridframework/framework/RDCloudApplication");
//	if (appClass == NULL) {
//		return false;
//	}
//	jmethodID appId = env->GetStaticMethodID(appClass, "getApp", "()Lcom/xhrd/mobile/hybridframework/framework/RDCloudApplication;");
//	if (!appId) {
//		return false;
//	}
//	jobject App = env->CallStaticObjectMethod(appClass, appId);
//	if (!App) {
//		return false;
//	}
//	jmethodID pkgManagerId = env->GetMethodID(appClass, "getPackageManager", "()Landroid/content/pm/PackageManager;");
//	if (!pkgManagerId) {
//		return false;
//	}
//	jobject pkgManager = env->CallObjectMethod(App, pkgManagerId);
//	if (!pkgManager) {
//		return false;
//	}
//	jclass pkgManagerClass = env->GetObjectClass(pkgManager);
//	jmethodID pkgInfoId = env->GetMethodID(pkgManagerClass, "getPackageInfo", "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");
//	if (!pkgInfoId) {
//		return false;
//	}
//	jstring pkgName = env->NewStringUTF(PKG_NAME);
//	if (!pkgName) {
//		return false;
//	}
//	jobject pkgInfo = env->CallObjectMethod(pkgManager, pkgInfoId, pkgName, 0x00000040);
//	env->DeleteLocalRef(pkgName);
//	if (!pkgInfo) {
//		return false;
//	}
//	jclass pkgInfoClass = env->GetObjectClass(pkgInfo);
//	jfieldID sigId = env->GetFieldID(pkgInfoClass, "signatures", "[Landroid/content/pm/Signature;");
//	jobjectArray sigs = (jobjectArray)env->GetObjectField(pkgInfo, sigId);
//	int size = env->GetArrayLength(sigs);
//	if (size == 0) {
//		return false;
//	}
//	jobject sig = env->GetObjectArrayElement(sigs, 0);
//	if (!sig) {
//		return false;
//	}
//	jclass sigClass = env->GetObjectClass(sig);
//
//	jmethodID toCharsStringId = env->GetMethodID(sigClass, "toCharsString", "()Ljava/lang/String;");
//	jstring sigStr = (jstring)env->CallObjectMethod(sig, toCharsStringId);
//	char *cp = jstrToStr(env, sigStr);
//	int ret = strcmp(SIGNATURE, (char*)cp);
////	LOGE("check signature cmp: %d", ret);
//	delete[] cp;
//	return ret == 0;
//}

//static const char *classPathName = strcat(PKG_NAME, "/engine/EncryptHelper");
static const char *classPathName = "com/xhrd/mobile/hybridframework/engine/RDEncryptHelper";
int checkSignature(JNIEnv *env) {
	jclass encClass = env->FindClass(classPathName);
	jmethodID methodId = env->GetStaticMethodID(encClass, "getMD5", "()Ljava/lang/String;");
	jstring md5 = (jstring)env->CallStaticObjectMethod(encClass, methodId);
	LOGE("md5: %s", jstrToStr(env, md5));
//	int ret = strcmp(md5, SIGNATURE);
//	return ret == 0;
	return 1;
}

/**
 * 检查包名
 */
int checkPackageName(JNIEnv *env) {
	jstring pkgName = getPackageName(env);
	char *pkgChars = jstrToStr(env, pkgName);
	//LOGE("%s", pkgChars);
	int ret = strcmp(PKG_NAME, pkgChars);
	delete pkgChars;
	return ret == 0;
}

int JNI_OnLoad(JavaVM* vm, void* reserved)
{
	JNIEnv* env = NULL;
	if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK)
	{
		return JNI_ERR;
	}
	jclass cls = env->FindClass(classPathName);
	if (cls == NULL)
	{
		return JNI_ERR;
	}
	int len = sizeof(s_methods) / sizeof(s_methods[0]);
	if (env->RegisterNatives(cls, s_methods, len) < 0)
	{
		return JNI_ERR;
	}

	//判断是否是debug模式
	isVerified = !isDebug(env);
	if (isVerified) {
		if (!checkSignature(env) || !checkPackageName(env)) {
			return JNI_ERR;
		}
	}
	LOGD("is verified: %d", isVerified);
	//isVerified = !isDebug(env);
	//checkSignature(env);
	return JNI_VERSION_1_4;
}

#ifdef __cplusplus
}
#endif
#endif
